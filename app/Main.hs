{-# LANGUAGE DataKinds #-}

module Main where

import qualified AggregateSignature.Program.Keelung as Keelung
import qualified AggregateSignature.Program.Snarkl as Snarkl
import AggregateSignature.Util
import Control.Monad
import Control.Monad.Except
import qualified Data.Set as Set
import Keelung (GF181)
import qualified Keelung
import qualified Snarkl

generateFlamegraph :: Bool
generateFlamegraph = True

main :: IO ()
main = do
  if generateFlamegraph
    then do
      let dimension = 2
      let numOfSigs = 1
      keelung dimension numOfSigs
    else do
      let parameters =
            [ -- (512, 16)
              -- ,
              -- , (1, 2)
              -- , (1, 4)
              -- (1, 1),
              -- (10, 1),
              -- (1, 10),
              -- (10, 10),
              (512, 1),
              (512, 2),
              (512, 4),
              (512, 8)
            ]

      forM_ parameters $ \(dimension, numOfSigs) -> do
        putStrLn $ show dimension ++ ":" ++ show numOfSigs
        -- snarklConstraints dimension numOfSigs
        -- keelung dimension numOfSigs

        keelungConstraints dimension numOfSigs

run :: ExceptT String IO () -> IO ()
run f = do
  res <- runExceptT f
  case res of
    Left err -> putStrLn err
    Right () -> return ()

--------------------------------------------------------------------------------

keelung :: Int -> Int -> IO ()
keelung dimension numOfSigs = run $ do
  let settings =
        Settings
          { enableAggSigChecking = True,
            enableSigSizeChecking = True,
            enableSigLengthChecking = True
          }
  let setup = makeSetup dimension numOfSigs 42 settings :: Setup GF181

  -- compile & optimise
  -- erased <- liftEither $ Keelung.erase (Keelung.aggregateSignature setup)
  -- liftIO $ do
  --   print ("erasedExpr", Keelung.Untyped.sizeOfExpr <$> Keelung.erasedExpr erased)
  --   print ("erasedAssertions", length $ Keelung.erasedAssertions erased, sum $ map Keelung.Untyped.sizeOfExpr (Keelung.erasedAssertions erased))
  --   print ("erasedAssignments", length $ Keelung.erasedAssignments erased, sum $ map (\(Keelung.Untyped.Assignment _ expr) -> Keelung.Untyped.sizeOfExpr expr) (Keelung.erasedAssignments erased))
  --   print ("erasedNumOfVars", Keelung.erasedNumOfVars erased)
  --   print ("erasedInputVars size", IntSet.size $ Keelung.erasedInputVars erased)
  --   print ("erasedBooleanVars size", IntSet.size $ Keelung.erasedBooleanVars erased)

  -- print ("compNextVar", Keelung.compNextVar computed)
  -- print ("compNextAddr", Keelung.compNextAddr computed)
  -- print ("compInputVars", IntSet.size $ Keelung.compInputVars computed)
  -- print ("compHeap", IntMap.size $ Keelung.compHeap computed)
  -- print ("compNumAsgns", length $ Keelung.compNumAsgns computed, sum $ map (\(Keelung.Assignment _ expr) -> Keelung.sizeOfExpr expr) (Keelung.compNumAsgns computed))
  -- print ("compBoolAsgns", length $ Keelung.compBoolAsgns computed, sum $ map (\(Keelung.Assignment _ expr) -> Keelung.sizeOfExpr expr) (Keelung.compBoolAsgns computed))
  -- print ("compAssertions", length $ Keelung.compAssertions computed, sum $ map Keelung.sizeOfExpr (Keelung.compAssertions computed))

  -- compile & optimise
  aggSig <- liftEither $ Keelung.optm (Keelung.aggregateSignature setup)
  liftIO $
    print (Keelung.numberOfConstraints aggSig)

-- for examing the number of constraints generated by Keelung
keelungConstraints :: Int -> Int -> IO ()
keelungConstraints dimension numOfSigs = run $ do
  let settings =
        Settings
          { enableAggSigChecking = True,
            enableSigSizeChecking = True,
            enableSigLengthChecking = True
          }
  let setup = makeSetup dimension numOfSigs 42 settings :: Setup GF181
  -- let input = genInputFromSetup setup

  checkAgg <-
    liftEither $
      Keelung.comp $
        Keelung.checkAgg $
          makeSetup dimension numOfSigs 42 (Settings True False False)
  let checkAgg' = Keelung.optimise checkAgg :: Keelung.ConstraintSystem GF181
  -- let checkAgg'' = snd $ Keelung.optimiseWithInput input checkAgg'

  checkSize <-
    liftEither $
      Keelung.comp $
        Keelung.checkSize $
          makeSetup dimension numOfSigs 42 (Settings False True False)
  let checkSize' = Keelung.optimise checkSize :: Keelung.ConstraintSystem GF181
  -- let checkSize'' = snd $ Keelung.optimiseWithInput input checkSize'

  checkLength <-
    liftEither $
      Keelung.comp $
        Keelung.checkLength $
          makeSetup dimension numOfSigs 42 (Settings False False True)
  let checkLength' = Keelung.optimise checkLength :: Keelung.ConstraintSystem GF181
  -- let checkLength'' = snd $ Keelung.optimiseWithInput input checkLength'

  aggSig <- liftEither $ Keelung.comp (Keelung.aggregateSignature setup)
  let aggSig' = Keelung.optimise aggSig :: Keelung.ConstraintSystem GF181
  -- let aggSig'' = snd $ Keelung.optimiseWithInput input aggSig'

  liftIO $ putStrLn "  Keelung: "
  liftIO $
    putStrLn $
      "    not optimised:      "
        ++ show (Keelung.numberOfConstraints aggSig)
        ++ " ( "
        ++ show (Keelung.numberOfConstraints checkAgg)
        ++ " / "
        ++ show (Keelung.numberOfConstraints checkSize)
        ++ " / "
        ++ show (Keelung.numberOfConstraints checkLength)
        ++ " )"
  liftIO $
    putStrLn $
      "    optimised:          "
        ++ show (Keelung.numberOfConstraints aggSig')
        ++ " ( "
        ++ show (Keelung.numberOfConstraints checkAgg')
        ++ " / "
        ++ show (Keelung.numberOfConstraints checkSize')
        ++ " / "
        ++ show (Keelung.numberOfConstraints checkLength')
        ++ " )"

-- liftIO $
--   putStrLn $
--     "    patially evaluated: "
--       ++ show (Keelung.numberOfConstraints aggSig''))
--       ++ " ( "
--       ++ show (Keelung.numberOfConstraints checkAgg''))
--       ++ " / "
--       ++ show (Keelung.numberOfConstraints checkSize''))
--       ++ " / "
--       ++ show (Keelung.numberOfConstraints checkLength''))
--       ++ " )"

-- for examing the number of constraints generated by Snarkl
snarklConstraints :: Int -> Int -> IO ()
snarklConstraints dimension numOfSigs = run $ do
  do
    -- not optimised

    let count =
          show . Set.size . Snarkl.cs_constraints
            . Snarkl.compile
            . Snarkl.elaborate

    liftIO $ putStrLn "  Snarkl: "
    liftIO $
      putStrLn $
        "    not optimised: "
          ++ count checkAgg
          ++ " / "
          ++ count checkSize
          ++ " / "
          ++ count checkLength
          ++ " / "
          ++ count aggSig

  do
    -- optimised
    let count =
          show . Set.size . Snarkl.cs_constraints . snd
            . Snarkl.simplifyConstrantSystem False mempty
            . Snarkl.compile
            . Snarkl.elaborate

    liftIO $
      putStrLn $
        "    optimised: "
          ++ count checkAgg
          ++ " / "
          ++ count checkSize
          ++ " / "
          ++ count checkLength
          ++ " / "
          ++ count aggSig
  where
    checkAgg :: Snarkl.Comp 'Snarkl.TBool GF181
    checkAgg = Snarkl.checkAgg $ makeSetup dimension numOfSigs 42 $ Settings True False False

    checkSize :: Snarkl.Comp 'Snarkl.TBool GF181
    checkSize = Snarkl.checkSize $ makeSetup dimension numOfSigs 42 $ Settings False True False

    checkLength :: Snarkl.Comp 'Snarkl.TBool GF181
    checkLength = Snarkl.checkLength $ makeSetup dimension numOfSigs 42 $ Settings False False True

    aggSig :: Snarkl.Comp 'Snarkl.TBool GF181
    aggSig = Snarkl.aggregateSignature $ makeSetup dimension numOfSigs 42 $ Settings True True True

-- for examing the complexity of expression generated after elaboration
keelungElaborate :: IO ()
keelungElaborate = do
  forM_ [2 :: Int .. 7] $ \i -> do
    let dimension = 2 ^ i
    let numOfSigs = 4
    let setup = makeSetup dimension numOfSigs 42 settings :: Setup GF181

    let result = Keelung.elaborate' (Keelung.aggregateSignature setup)
    case result of
      Left err -> print err
      Right elaborated -> do
        print
          ( Keelung.sizeOfExpr <$> Keelung.elabExpr elaborated,
            length (Keelung.compNumAsgns (Keelung.elabComp elaborated)),
            length (Keelung.compBoolAsgns (Keelung.elabComp elaborated)),
            Keelung.compNextVar (Keelung.elabComp elaborated)
          )
  where
    -- run (2 ^ i) 4

    settings :: Settings
    settings =
      Settings
        { enableAggSigChecking = True,
          enableSigSizeChecking = True,
          enableSigLengthChecking = True
        }