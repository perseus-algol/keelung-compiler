{-# LANGUAGE DataKinds #-}

module Main where

import qualified AggregateSignature.Program as AggSig
import AggregateSignature.Util
import Control.Arrow (left)
import Control.Monad
import Control.Monad.Except
import qualified Data.ByteString.Char8 as BSC
import Data.Serialize (decode, encode)
import Keelung (elaborate)
import Keelung.Compiler
  ( ConstraintSystem,
    Error (..),
    compile,
    interpElab,
    numberOfConstraints,
    optimize,
    optimizeElab,
    toR1CS,
  )
import qualified Keelung.Compiler.Optimize as Optimizer
import Keelung.Constraint.R1CS (R1CS)
import Keelung.Field
import Keelung.Syntax.Typed hiding (elaborate)
import Option

main :: IO ()
main = do
  options <- getOptions
  case options of
    Protocol ToR1CS -> do
      blob <- getContents
      let decoded = decode (BSC.pack blob) :: Either String Elaborated
      case decoded of
        Left err -> print err
        Right elaborated -> do
          case compFieldType (elabComp elaborated) of
            B64 -> putStrLn $ BSC.unpack $ encode (left show (toR1CS <$> optimizeElab elaborated) :: Either String (R1CS B64))
            GF181 -> putStrLn $ BSC.unpack $ encode (left show (toR1CS <$> optimizeElab elaborated) :: Either String (R1CS GF181))
            BN128 -> putStrLn $ BSC.unpack $ encode (left show (toR1CS <$> optimizeElab elaborated) :: Either String (R1CS BN128))
    Protocol Interpret -> do
      blob <- getContents
      let decoded = decode (BSC.pack blob) :: Either String (Elaborated, [Integer])
      case decoded of
        Left err -> print err
        Right (elaborated, inputs) -> do
          case compFieldType (elabComp elaborated) of
            B64 -> putStrLn $ BSC.unpack $ encode (interpElab elaborated (map fromInteger inputs) :: Either String [B64])
            GF181 -> putStrLn $ BSC.unpack $ encode (interpElab elaborated (map fromInteger inputs) :: Either String [GF181])
            BN128 -> putStrLn $ BSC.unpack $ encode (interpElab elaborated (map fromInteger inputs) :: Either String [BN128])
    Profile dimension numOfSigs -> profile dimension numOfSigs
    Count dimension numOfSigs -> do
      putStrLn $ show dimension ++ ":" ++ show numOfSigs
      -- snarklConstraints dimension numOfSigs
      -- keelung dimension numOfSigs
      keelungConstraints dimension numOfSigs

run :: (Show n, Bounded n, Integral n, Fractional n) => ExceptT (Error n) IO () -> IO ()
run f = do
  res <- runExceptT f
  case res of
    Left err -> print err
    Right () -> return ()

--------------------------------------------------------------------------------

profile :: Int -> Int -> IO ()
profile dimension numOfSigs = run $ do
  let settings =
        Settings
          { enableAggChecking = True,
            enableSizeChecking = True,
            enableLengthChecking = True
          }
  let param = makeParam dimension numOfSigs 42 settings :: Param GF181

  -- compile & optimize
  -- erased <- liftEither $ erase (aggregateSignature setup)
  -- liftIO $ do
  --   print ("erasedExpr", Untyped.sizeOfExpr <$> erasedExpr erased)
  --   print ("erasedAssertions", length $ erasedAssertions erased, sum $ map Untyped.sizeOfExpr (erasedAssertions erased))
  --   print ("erasedAssignments", length $ erasedAssignments erased, sum $ map (\(Untyped.Assignment _ expr) -> Untyped.sizeOfExpr expr) (erasedAssignments erased))
  --   print ("erasedNumOfVars", erasedNumOfVars erased)
  --   print ("erasedInputVars size", IntSet.size $ erasedInputVars erased)
  --   print ("erasedBooleanVars size", IntSet.size $ erasedBooleanVars erased)

  -- print ("compNextVar", compNextVar computed)
  -- print ("compNextAddr", compNextAddr computed)
  -- print ("compInputVars", IntSet.size $ compInputVars computed)
  -- print ("compHeap", IntMap.size $ compHeap computed)
  -- print ("compNumAsgns", length $ compNumAsgns computed, sum $ map (\(Assignment _ expr) -> sizeOfExpr expr) (compNumAsgns computed))
  -- print ("compBoolAsgns", length $ compBoolAsgns computed, sum $ map (\(Assignment _ expr) -> sizeOfExpr expr) (compBoolAsgns computed))
  -- print ("compAssertions", length $ compAssertions computed, sum $ map sizeOfExpr (compAssertions computed))

  -- compile & optimize
  aggSig <- liftEither $ optimize (AggSig.aggregateSignature param)
  liftIO $
    print (numberOfConstraints aggSig)

-- for examing the number of constraints generated by Keelung
keelungConstraints :: Int -> Int -> IO ()
keelungConstraints dimension numOfSigs = run $ do
  let settings =
        Settings
          { enableAggChecking = True,
            enableSizeChecking = True,
            enableLengthChecking = True
          }
  let param = makeParam dimension numOfSigs 42 settings :: Param GF181

  checkAgg <-
    liftEither $
      compile $
        AggSig.checkAgg $
          makeParam dimension numOfSigs 42 (Settings True False False)
  let checkAgg' = Optimizer.optimize2 $ Optimizer.optimize checkAgg :: ConstraintSystem GF181

  checkSize <-
    liftEither $
      compile $
        AggSig.checkSize $
          makeParam dimension numOfSigs 42 (Settings False True False)
  let checkSize' = Optimizer.optimize2 $ Optimizer.optimize checkSize :: ConstraintSystem GF181

  checkLength <-
    liftEither $
      compile $
        AggSig.checkLength $
          makeParam dimension numOfSigs 42 (Settings False False True)
  let checkLength' = Optimizer.optimize2 $ Optimizer.optimize checkLength :: ConstraintSystem GF181

  aggSig <- liftEither $ compile (AggSig.aggregateSignature param)
  let aggSig' = Optimizer.optimize2 $ Optimizer.optimize aggSig :: ConstraintSystem GF181

  liftIO $ putStrLn "  Keelung: "
  liftIO $
    putStrLn $
      "    not optimized:      "
        ++ show (numberOfConstraints aggSig)
        ++ " ( "
        ++ show (numberOfConstraints checkAgg)
        ++ " / "
        ++ show (numberOfConstraints checkSize)
        ++ " / "
        ++ show (numberOfConstraints checkLength)
        ++ " )"
  liftIO $
    putStrLn $
      "    optimized:          "
        ++ show (numberOfConstraints aggSig')
        ++ " ( "
        ++ show (numberOfConstraints checkAgg')
        ++ " / "
        ++ show (numberOfConstraints checkSize')
        ++ " / "
        ++ show (numberOfConstraints checkLength')
        ++ " )"

-- liftIO $
--   putStrLn $
--     "    patially evaluated: "
--       ++ show (numberOfConstraints aggSig''))
--       ++ " ( "
--       ++ show (numberOfConstraints checkAgg''))
--       ++ " / "
--       ++ show (numberOfConstraints checkSize''))
--       ++ " / "
--       ++ show (numberOfConstraints checkLength''))
--       ++ " )"

-- for examing the number of constraints generated by Snarkl
-- snarklConstraints :: Int -> Int -> IO ()
-- snarklConstraints dimension numOfSigs = run $ do
--   do
--     -- not optimized

--     let count =
--           show . Set.size . Snarkl.cs_constraints
--             . Snarkl.compile
--             . Snarkl.elaborate

--     liftIO $ putStrLn "  Snarkl: "
--     liftIO $
--       putStrLn $
--         "    not optimized: "
--           ++ count checkAgg
--           ++ " / "
--           ++ count checkSize
--           ++ " / "
--           ++ count checkLength
--           ++ " / "
--           ++ count aggSig

--   do
--     -- optimized
--     let count =
--           show . Set.size . Snarkl.cs_constraints . snd
--             . Snarkl.simplifyConstrantSystem False mempty
--             . Snarkl.compile
--             . Snarkl.elaborate

--     liftIO $
--       putStrLn $
--         "    optimized: "
--           ++ count checkAgg
--           ++ " / "
--           ++ count checkSize
--           ++ " / "
--           ++ count checkLength
--           ++ " / "
--           ++ count aggSig
--   where
--     checkAgg :: Snarkl.Comp 'Snarkl.TBool GF181
--     checkAgg = Snarkl.checkAgg $ makeParam dimension numOfSigs 42 $ Settings True False False

--     checkSize :: Snarkl.Comp 'Snarkl.TBool GF181
--     checkSize = Snarkl.checkSize $ makeParam dimension numOfSigs 42 $ Settings False True False

--     checkLength :: Snarkl.Comp 'Snarkl.TBool GF181
--     checkLength = Snarkl.checkLength $ makeParam dimension numOfSigs 42 $ Settings False False True

--     aggSig :: Snarkl.Comp 'Snarkl.TBool GF181
--     aggSig = Snarkl.aggregateSignature $ makeParam dimension numOfSigs 42 $ Settings True True True

-- for examing the complexity of expression generated after elaboration
keelungElaborate :: IO ()
keelungElaborate = do
  forM_ [2 :: Int .. 7] $ \i -> do
    let dimension = 2 ^ i
    let numOfSigs = 4
    let param = makeParam dimension numOfSigs 42 settings :: Param GF181

    let result = elaborate (AggSig.aggregateSignature param)
    case result of
      Left err -> print err
      Right elaborated -> do
        print
          ( sizeOfExpr (elabExpr elaborated),
            length (compNumAsgns (elabComp elaborated)),
            length (compBoolAsgns (elabComp elaborated)),
            compNextVar (elabComp elaborated)
          )
  where
    -- run (2 ^ i) 4

    settings :: Settings
    settings =
      Settings
        { enableAggChecking = True,
          enableSizeChecking = True,
          enableLengthChecking = True
        }