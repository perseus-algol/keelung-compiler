{-# LANGUAGE DataKinds #-}

module Main where

import qualified AggregateSignature.Program as AggSig
import AggregateSignature.Util
import Control.Monad
import Control.Monad.Except
import Keelung.Compiler

generateFlamegraph :: Bool
generateFlamegraph = False

main :: IO ()
main = do
  if generateFlamegraph
    then do
      let dimension = 1
      let numOfSigs = 1
      keelung dimension numOfSigs
    else do
      let parameters =
            [ -- (512, 16)
              -- ,
              -- , (1, 2)
              -- , (1, 4)
              -- (1, 1),
              -- (10, 1),
              -- (1, 10),
              -- (10, 10),
              (512, 1),
              (512, 2),
              (512, 4),
              (512, 8)
            ]

      forM_ parameters $ \(dimension, numOfSigs) -> do
        putStrLn $ show dimension ++ ":" ++ show numOfSigs
        -- snarklConstraints dimension numOfSigs
        -- keelung dimension numOfSigs

        keelungConstraints dimension numOfSigs

run :: (Show n, Bounded n, Integral n, Fractional n) => ExceptT (Error n) IO () -> IO ()
run f = do
  res <- runExceptT f
  case res of
    Left err -> print err
    Right () -> return ()

--------------------------------------------------------------------------------

keelung :: Int -> Int -> IO ()
keelung dimension numOfSigs = run $ do
  let settings =
        Settings
          { enableAggChecking = True,
            enableSizeChecking = True,
            enableLengthChecking = True
          }
  let param = makeParam dimension numOfSigs 42 settings :: Param GF181

  -- compile & optimise
  -- erased <- liftEither $ erase (aggregateSignature setup)
  -- liftIO $ do
  --   print ("erasedExpr", Untyped.sizeOfExpr <$> erasedExpr erased)
  --   print ("erasedAssertions", length $ erasedAssertions erased, sum $ map Untyped.sizeOfExpr (erasedAssertions erased))
  --   print ("erasedAssignments", length $ erasedAssignments erased, sum $ map (\(Untyped.Assignment _ expr) -> Untyped.sizeOfExpr expr) (erasedAssignments erased))
  --   print ("erasedNumOfVars", erasedNumOfVars erased)
  --   print ("erasedInputVars size", IntSet.size $ erasedInputVars erased)
  --   print ("erasedBooleanVars size", IntSet.size $ erasedBooleanVars erased)

  -- print ("compNextVar", compNextVar computed)
  -- print ("compNextAddr", compNextAddr computed)
  -- print ("compInputVars", IntSet.size $ compInputVars computed)
  -- print ("compHeap", IntMap.size $ compHeap computed)
  -- print ("compNumAsgns", length $ compNumAsgns computed, sum $ map (\(Assignment _ expr) -> sizeOfExpr expr) (compNumAsgns computed))
  -- print ("compBoolAsgns", length $ compBoolAsgns computed, sum $ map (\(Assignment _ expr) -> sizeOfExpr expr) (compBoolAsgns computed))
  -- print ("compAssertions", length $ compAssertions computed, sum $ map sizeOfExpr (compAssertions computed))

  -- compile & optimise
  aggSig <- liftEither $ optm (AggSig.aggregateSignature param)
  liftIO $
    print (numberOfConstraints aggSig)

-- for examing the number of constraints generated by Keelung
keelungConstraints :: Int -> Int -> IO ()
keelungConstraints dimension numOfSigs = run $ do
  let settings =
        Settings
          { enableAggChecking = True,
            enableSizeChecking = True,
            enableLengthChecking = True
          }
  let param = makeParam dimension numOfSigs 42 settings :: Param GF181
  -- let input = genInputFromParam setup

  checkAgg <-
    liftEither $
      comp $
        AggSig.checkAgg $
          makeParam dimension numOfSigs 42 (Settings True False False)
  let checkAgg' = optimise2 $ optimise checkAgg :: ConstraintSystem GF181
  -- let checkAgg'' = snd $ optimiseWithInput input checkAgg'

  checkSize <-
    liftEither $
      comp $
        AggSig.checkSize $
          makeParam dimension numOfSigs 42 (Settings False True False)
  let checkSize' = optimise2 $ optimise checkSize :: ConstraintSystem GF181
  -- let checkSize'' = snd $ optimiseWithInput input checkSize'

  checkLength <-
    liftEither $
      comp $
        AggSig.checkLength $
          makeParam dimension numOfSigs 42 (Settings False False True)
  let checkLength' = optimise2 $ optimise checkLength :: ConstraintSystem GF181
  -- let checkLength'' = snd $ optimiseWithInput input checkLength'

  aggSig <- liftEither $ comp (AggSig.aggregateSignature param)
  let aggSig' = optimise2 $ optimise aggSig :: ConstraintSystem GF181
  -- let aggSig'' = snd $ optimiseWithInput input aggSig'

  liftIO $ putStrLn "  Keelung: "
  liftIO $
    putStrLn $
      "    not optimised:      "
        ++ show (numberOfConstraints aggSig)
        ++ " ( "
        ++ show (numberOfConstraints checkAgg)
        ++ " / "
        ++ show (numberOfConstraints checkSize)
        ++ " / "
        ++ show (numberOfConstraints checkLength)
        ++ " )"
  liftIO $
    putStrLn $
      "    optimised:          "
        ++ show (numberOfConstraints aggSig')
        ++ " ( "
        ++ show (numberOfConstraints checkAgg')
        ++ " / "
        ++ show (numberOfConstraints checkSize')
        ++ " / "
        ++ show (numberOfConstraints checkLength')
        ++ " )"

-- liftIO $
--   putStrLn $
--     "    patially evaluated: "
--       ++ show (numberOfConstraints aggSig''))
--       ++ " ( "
--       ++ show (numberOfConstraints checkAgg''))
--       ++ " / "
--       ++ show (numberOfConstraints checkSize''))
--       ++ " / "
--       ++ show (numberOfConstraints checkLength''))
--       ++ " )"

-- for examing the number of constraints generated by Snarkl
-- snarklConstraints :: Int -> Int -> IO ()
-- snarklConstraints dimension numOfSigs = run $ do
--   do
--     -- not optimised

--     let count =
--           show . Set.size . Snarkl.cs_constraints
--             . Snarkl.compile
--             . Snarkl.elaborate

--     liftIO $ putStrLn "  Snarkl: "
--     liftIO $
--       putStrLn $
--         "    not optimised: "
--           ++ count checkAgg
--           ++ " / "
--           ++ count checkSize
--           ++ " / "
--           ++ count checkLength
--           ++ " / "
--           ++ count aggSig

--   do
--     -- optimised
--     let count =
--           show . Set.size . Snarkl.cs_constraints . snd
--             . Snarkl.simplifyConstrantSystem False mempty
--             . Snarkl.compile
--             . Snarkl.elaborate

--     liftIO $
--       putStrLn $
--         "    optimised: "
--           ++ count checkAgg
--           ++ " / "
--           ++ count checkSize
--           ++ " / "
--           ++ count checkLength
--           ++ " / "
--           ++ count aggSig
--   where
--     checkAgg :: Snarkl.Comp 'Snarkl.TBool GF181
--     checkAgg = Snarkl.checkAgg $ makeParam dimension numOfSigs 42 $ Settings True False False

--     checkSize :: Snarkl.Comp 'Snarkl.TBool GF181
--     checkSize = Snarkl.checkSize $ makeParam dimension numOfSigs 42 $ Settings False True False

--     checkLength :: Snarkl.Comp 'Snarkl.TBool GF181
--     checkLength = Snarkl.checkLength $ makeParam dimension numOfSigs 42 $ Settings False False True

--     aggSig :: Snarkl.Comp 'Snarkl.TBool GF181
--     aggSig = Snarkl.aggregateSignature $ makeParam dimension numOfSigs 42 $ Settings True True True

-- for examing the complexity of expression generated after elaboration
keelungElaborate :: IO ()
keelungElaborate = do
  forM_ [2 :: Int .. 7] $ \i -> do
    let dimension = 2 ^ i
    let numOfSigs = 4
    let param = makeParam dimension numOfSigs 42 settings :: Param GF181

    let result = elaborate' (AggSig.aggregateSignature param)
    case result of
      Left err -> print err
      Right elaborated -> do
        print
          ( sizeOfExpr <$> elabExpr elaborated,
            length (compNumAsgns (elabComp elaborated)),
            length (compBoolAsgns (elabComp elaborated)),
            compNextVar (elabComp elaborated)
          )
  where
    -- run (2 ^ i) 4

    settings :: Settings
    settings =
      Settings
        { enableAggChecking = True,
          enableSizeChecking = True,
          enableLengthChecking = True
        }